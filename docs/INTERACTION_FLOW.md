# 日常提醒助手 - 完整交互文档

## 一、规则配置（Settings 页面）

### 1.1 创建规则

用户在 Options 页面可以创建多条提醒规则，每条规则包含：

```yaml
规则示例 1 - 吃午饭提醒:
  名称: '吃午饭'
  启用状态: ✅ 已启用
  工作日: 周一到周五
  提醒时间段: 11:30 - 12:00
  提醒间隔: 每 10 分钟
  迟到补提醒: 12:30
  通知标题: '该吃午饭啦！'
  通知消息: '吃点自己喜欢的东西～'
  Toast 消息: '别忘了吃午饭！'
  Toast 持续时间: 10 秒
  模板内容: '吃点自己喜欢的东西～'

规则示例 2 - 晚上睡觉提醒:
  名称: '晚上睡觉提醒'
  启用状态: ✅ 已启用
  工作日: 每天
  提醒时间段: 23:30 - 00:00
  提醒间隔: 每 10 分钟
  迟到补提醒: 无
  通知标题: '该睡觉了！'
  通知消息: '赶紧睡觉，狗命要紧啊～'
  Toast 消息: '该睡觉了！'
  Toast 持续时间: 10 秒
  模板内容: '赶紧睡觉，狗命要紧啊～'
```

### 1.2 规则存储

- 所有规则保存在 `chrome.storage.sync` 中
- 每条规则有唯一的 `id`（如：`rule-1729123456789`）

---

## 二、后台提醒调度逻辑（Background Service）

### 2.1 初始化

浏览器启动或扩展安装时：

```
1. 读取配置中的所有规则
2. 读取当日状态（completedRules: []）
3. 遍历所有启用的规则，找出下一个最早的提醒时间
4. 创建 Chrome Alarm 定时器
```

### 2.2 提醒时间计算（针对单条规则）

**示例：吃午饭规则（11:30 - 12:00，每 10 分钟）**

当前时间 10:00：

- 计算结果：下一次提醒时间 = 11:30（首次提醒）

当前时间 11:35：

- 计算结果：下一次提醒时间 = 11:40（第二次提醒）
- 提醒时间点：11:30, 11:40, 11:50, 12:00

当前时间 12:05：

- 超过 deadline (12:00)
- 检查迟到补提醒：12:30
- 计算结果：下一次提醒时间 = 12:30

当前时间 12:35：

- 所有提醒时间都已过
- 计算结果：null（今天不再提醒）

### 2.3 多规则调度策略

**场景：周一下午 1 点**

当前配置：

- 规则 A：吃午饭（11:30-12:00）
- 规则 B：晚上睡觉（23:30-00:00）

调度过程：

```
1. 检查规则 A：
   - 当前时间 13:00 > deadline 12:00
   - 没有迟到补提醒
   - 规则 A 今天不再提醒 ❌

2. 检查规则 B：
   - 当前时间 13:00 < 开始时间 23:30
   - 下一次提醒 = 今天 23:30 ✅

3. 调度决策：
   - 设置 Alarm 在 23:30 触发
```

### 2.4 Alarm 触发时

当 Alarm 在 23:30 触发：

```
1. 读取当日状态：completedRules = []

2. 检查所有启用的规则，找出当前时间应该提醒的规则：
   - 规则 A（吃午饭）：已过时间，跳过 ❌
   - 规则 B（晚上睡觉）：23:30 匹配 ✅

3. 检查规则 B 是否已完成：
   - completedRules 中没有 规则B的ID
   - 未完成，继续提醒 ✅

4. 发送提醒：
   - 系统通知：显示 "该睡觉了！"
   - Toast 弹窗：在所有网页显示 Toast
   - Badge：扩展图标显示 "!" 红点

5. 安排下一次提醒：
   - 规则 B 的下一次提醒 = 23:40
   - 设置新的 Alarm 在 23:40
```

---

## 三、Popup 交互流程

### 3.1 打开 Popup 时

**场景：周一下午 1 点打开 Popup**

当前状态：

- 规则 A（吃午饭）：未完成
- 规则 B（晚上睡觉）：未完成

显示逻辑：

```
1. 读取所有启用的规则
2. 过滤掉已完成的规则：
   - 规则 A：completedRules 中没有，保留 ✅
   - 规则 B：completedRules 中没有，保留 ✅

3. 计算每条规则的下一次提醒时间：
   - 规则 A：null（已过提醒时间段）
   - 规则 B：23:30

4. 选择下一次提醒时间最早的规则：
   - 规则 B（23:30）更早
   - 显示规则 B 的信息 ✓
```

**Popup 显示内容：**

```
┌─────────────────────────────────┐
│ 日常提醒助手              ⚙️    │
│ 13:41                           │
│ ⏰ 待完成                       │
├─────────────────────────────────┤
│ 晚上睡觉提醒                     │
│ 23:30 - 00:00 · 每 10 分钟一次  │
│                                 │
│ 提醒内容               [复制]   │
│ ┌─────────────────────────────┐ │
│ │ 赶紧睡觉，狗命要紧啊～        │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │     ✓ Mark as Done          │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

### 3.2 点击 "Mark as Done"

**用户操作：点击 "Mark as Done" 按钮**

执行流程：

```
1. 发送消息到 Background：
   {
     type: 'MARK_RULE_COMPLETED',
     payload: { ruleId: 'rule-睡觉-id' }
   }

2. Background 处理：
   - 读取当前状态：completedRules = []
   - 添加规则 ID：completedRules = ['rule-睡觉-id']
   - 保存状态

3. 检查是否所有规则都完成：
   - 启用的规则：规则A, 规则B
   - 已完成：规则B
   - 结果：还有规则未完成 ❌

4. 重新调度：
   - 规则 A：已过时间，null
   - 规则 B：已完成，跳过
   - 没有更多提醒，清除所有 Alarm

5. Popup 自动刷新，重新读取状态
```

### 3.3 Popup 刷新后显示

**刷新后的状态：**

- 规则 A（吃午饭）：未完成
- 规则 B（晚上睡觉）：已完成 ✅

显示逻辑：

```
1. 过滤掉已完成的规则：
   - 规则 A：未完成，保留 ✅
   - 规则 B：已完成，跳过 ❌

2. 计算剩余规则的下一次提醒时间：
   - 规则 A：null（已过时间）

3. 选择结果：
   - 没有未完成且有下一次提醒的规则
   - nextActiveRule = null
```

**Popup 显示内容：**

```
┌─────────────────────────────────┐
│ 日常提醒助手              ⚙️    │
│ 13:42                           │
│ ✅ 今日已完成                   │
├─────────────────────────────────┤
│ （没有显示任何规则内容）         │
│                                 │
│ （没有 Mark as Done 按钮）       │
└─────────────────────────────────┘
```

### 3.4 第二天场景

**第二天周二 11:00 打开 Popup**

系统自动重置：

- 午夜 00:00，Background 自动重置 completedRules = []

当前状态：

- 规则 A（吃午饭）：未完成
- 规则 B（晚上睡觉）：未完成

显示逻辑：

```
1. 过滤规则：
   - 规则 A：未完成，保留 ✅
   - 规则 B：未完成，保留 ✅

2. 计算下一次提醒时间：
   - 规则 A：11:30（30分钟后）
   - 规则 B：23:30（12.5小时后）

3. 选择最早的：
   - 规则 A（11:30）更早
   - 显示规则 A
```

**Popup 显示：**

```
┌─────────────────────────────────┐
│ 日常提醒助手              ⚙️    │
│ 11:00                           │
│ ⏰ 待完成 · 30分钟后             │
├─────────────────────────────────┤
│ 吃午饭                          │
│ 11:30 - 12:00 · 每 10 分钟一次  │
│                                 │
│ 提醒内容               [复制]   │
│ ┌─────────────────────────────┐ │
│ │ 吃点自己喜欢的东西～          │ │
│ └─────────────────────────────┘ │
│                                 │
│ ┌─────────────────────────────┐ │
│ │     ✓ Mark as Done          │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

---

## 四、完整链路示例（周一全天）

### 时间线：周一

**11:25 - 用户打开 Popup**

```
显示：吃午饭规则（11:30开始，5分钟后）
按钮：Mark as Done
```

**11:30 - 到达提醒时间**

```
系统操作：
1. Alarm 触发
2. 检查：规则A（吃午饭）未完成
3. 发送通知 + Toast
4. 设置下一次 Alarm = 11:40
```

**11:35 - 用户点击 Mark as Done**

```
操作：
1. 标记规则A为完成：completedRules = ['rule-A-id']
2. 取消当前 Alarm
3. 重新调度（找下一个未完成的规则）
4. Popup 刷新

显示：晚上睡觉规则（23:30开始）
按钮：Mark as Done
```

**13:00 - 用户再次打开 Popup**

```
显示：晚上睡觉规则（23:30开始，10.5小时后）
按钮：Mark as Done
```

**23:30 - 到达提醒时间**

```
系统操作：
1. Alarm 触发
2. 检查：规则B（晚上睡觉）未完成
3. 发送通知 + Toast
4. 设置下一次 Alarm = 23:40
```

**23:35 - 用户点击 Mark as Done**

```
操作：
1. 标记规则B为完成：completedRules = ['rule-A-id', 'rule-B-id']
2. 检查：所有规则都完成 ✅
3. 清除所有 Alarm
4. 清除 Badge 红点
5. Popup 刷新

显示：✅ 今日已完成
按钮：无
```

**00:00 - 午夜自动重置**

```
系统操作：
1. 重置状态：completedRules = []
2. 重新计算所有规则的提醒时间
3. 设置新的 Alarm（周二的提醒）
```

---

## 五、关键规则

### 5.1 Popup 显示优先级

```
1. 只显示一条规则（不是全部）
2. 选择逻辑：
   - 过滤掉已完成的规则（completedRules 数组）
   - 计算每条未完成规则的下一次提醒时间
   - 选择时间最早的那条规则
3. 如果所有规则都完成 → 显示 "今日已完成"
4. 如果没有规则有下一次提醒 → 也显示 "今日已完成"
```

### 5.2 Mark as Done 行为

```
1. 只标记当前显示的这一条规则为完成
2. 将规则 ID 添加到 completedRules 数组
3. 不影响其他规则
4. 标记后自动刷新 Popup，显示下一条规则
5. 已完成的规则不会再提醒
```

### 5.3 规则独立性

```
1. 每条规则有独立的完成状态（通过 completedRules 数组管理）
2. 每条规则有独立的提醒时间计算
3. 规则之间互不影响
4. getNextReminderTime 会检查规则 ID 是否在 completedRules 中
```

### 5.4 调度策略

```
1. Background 始终维护一个全局 Alarm
2. Alarm 时间 = 所有未完成规则中最早的提醒时间
3. Alarm 触发时，检查所有在当前时间应该提醒的规则
4. 只提醒未完成的规则（不在 completedRules 中）
5. 发送提醒后，重新计算下一个 Alarm 时间
```

---

## 六、边界情况

### 6.1 所有规则都已完成

- Popup 显示：✅ 今日已完成
- 没有 Mark as Done 按钮
- Background 不设置任何 Alarm

### 6.2 所有规则都已过提醒时间

- Popup 显示：✅ 今日已完成
- 虽然规则未标记完成，但没有下一次提醒时间

### 6.3 周末（非工作日）

- 如果规则设置为周一到周五
- 周六日打开 Popup：显示 "非工作日"
- 不发送任何提醒

### 6.4 只有一条规则

- 直接显示该规则
- 点击 Mark as Done 后显示 "今日已完成"

### 6.5 部分规则已完成

- 只显示下一个未完成的规则
- 已完成的规则在 `getNextReminderTime` 中返回 null
- Popup 自动过滤已完成的规则

---

## 七、核心函数说明

### 7.1 `getNextReminderTime(now, rule, state)`

```typescript
功能：计算单条规则的下一次提醒时间

检查顺序：
1. 检查 rule.id 是否在 state.completedRules 中
   - 如果在，返回 null（已完成）
2. 兼容旧版本：检查 state.sent
   - 如果为 true，返回 null
3. 检查是否是工作日
   - 如果不是，返回 null
4. 计算下一次提醒时间
   - 如果还没到开始时间，返回开始时间
   - 如果在时间段内，返回下一个间隔时间点
   - 如果超过 deadline，检查迟到补提醒
   - 如果都没有，返回 null

返回值：
- Date 对象：下一次提醒时间
- null：今天不再提醒
```

### 7.2 Popup 的 `getNextRuleEntry()`

```typescript
功能：从所有启用的规则中找出下一个要显示的规则

逻辑：
1. 遍历所有 enabled 的规则
2. 跳过已完成的规则（completedRules 中的）
3. 调用 getNextReminderTime 计算下一次提醒时间
4. 选择提醒时间最早的规则
5. 返回 { rule, time } 或 null

Popup 只显示这一条规则
```

### 7.3 Background 的 `scheduleNextReminder()`

```typescript
功能：安排下一次提醒的 Alarm

逻辑：
1. 读取 state.completedRules
2. 遍历所有 enabled 的规则
3. 跳过已在 completedRules 中的规则
4. 计算每条规则的下一次提醒时间
5. 选择最早的时间设置 Alarm
6. 如果没有任何规则需要提醒，不设置 Alarm
```

---

## 八、数据结构

### 8.1 DailyState

```typescript
interface DailyState {
  date: string // "YYYY-MM-DD"
  completedRules: string[] // 已完成的规则ID列表
  sent?: boolean // 旧版本兼容字段
  lastRemindTime?: string // ISO 时间字符串
}
```

### 8.2 消息类型

```typescript
// 标记规则完成
{
  type: 'MARK_RULE_COMPLETED',
  payload: { ruleId: string }
}

// 旧版本兼容（标记所有规则完成）
{
  type: 'MARK_SENT'
}
```

---

这个文档完整描述了从配置规则到提醒触发，再到用户标记完成的整个交互流程。
